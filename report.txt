Η παρούσα εργασία για την υλοποίησης της Copy On Write για το fork() έχει βασιστεί πάνω στις υποδείξεις που δόθηκαν στην εκφώνηση της εργασίας.

Τροποποιείται η uvmcopy() στο vm.c ώστε να αντιστοιχίζει τις φυσικές σελίδες μνήμης του γονέα στο παιδί μέσω της κλήσης mappages(new, i, PGSIZE, (uint64)pa, flags).
Μαρκάρονται ίσα με 1 τα PTE_FLAGS για το write ώστε να μην μπορεί να γραφτεί στις σελίδες κάτι, καθώς τις μοιράζεται η γονική διεργασία αλλά και το παιδί.
Το reference_counter που έχει οριστή στην kalloc.c δείχνει πόσοι μοιράζονται εκείνη την σελίδα μνήμης. Αφού εκτός από την γονική διεργασία, την μοιράζεται
και το παιδί, το reference_counter θα μεγαλώσει κατα 1. Επίσης έχουμε δημιουργήσει άλλο ένα PTE_FLAG, το PTE_COW όπου δείχνει ότι η σελίδα έχει περάσει από
την Copy On Write βελτίωση του fork().

Έπειτα, τροποποιείται η usertrap() ώστε να αναγνωρίζει το σφάλμα σελίδας για μια CoW σελίδα. Το σφάλμα προκαλείται διότι θέλει κάποιος να γράψει πάνω στην σελίδα.
Κανονικά θα μπορούσε καθώς ήταν writable. Όμως λόγω της CoW τεχνικής, το είχαμε απαγορέψει για να γλιτώσουμε μια αντιγραφή που μπορεί να μην χρειαζόταν.
Τώρα φαίνεται οτι χρειάζεται να ανατεθεί μια νέα σελίδα μέσω της kalloc(), να αντιγράψει την παλιά σελίδα στην νέα και να κάνει την νέα σελίδα writable (PTE_W ίσο με 1).

Μετά πρέπει να βεβαιώνει το σύστημα ότι οι φυσικές σελίδες απελευθερώνονται μόνο όταν μηδενίζονται οι αναφορες σε αυτή απο PTE, δηλαδή το reference_counter να είναι
ίσο με 0. Για αυτό δημιουργήθηκε και το reference_counter όπου τροποποιήθηκε η kalloc() και η kfree() ώστε να αρχικοποιείται με 1, να αυξάνεται ο μετρητής στην uvmcopy
, να μειώνεται ο μετρητής όταν μια διεργασία αφιρεί τη σελίδα από τον πίνακα σελίδων της και η kfree() να επιστρέφει τη σελίδα στη λίστα με τις διαθέσιμες σελίδες μόνο
όταν το reference_counter μειωθεί στο 0.

Τέλος, τροποποιείται και η copyout() ώστε να αντιμετωπίζει, όπως κάναμε και στην usertrap(), τις CoW σελίδες. 